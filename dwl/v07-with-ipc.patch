diff --git a/Makefile b/Makefile
index 3358bae..28ed034 100644
--- a/Makefile
+++ b/Makefile
@@ -17,12 +17,14 @@ DWLCFLAGS = `$(PKG_CONFIG) --cflags $(PKGS)` $(DWLCPPFLAGS) $(DWLDEVCFLAGS) $(CF
 LDLIBS    = `$(PKG_CONFIG) --libs $(PKGS)` -lm $(LIBS)
 
 all: dwl
-dwl: dwl.o util.o
-	$(CC) dwl.o util.o $(DWLCFLAGS) $(LDFLAGS) $(LDLIBS) -o $@
+dwl: dwl.o util.o dwl-ipc-unstable-v2-protocol.o
+	$(CC) dwl.o util.o dwl-ipc-unstable-v2-protocol.o $(DWLCFLAGS) $(LDFLAGS) $(LDLIBS) -o $@
 dwl.o: dwl.c client.h config.h config.mk cursor-shape-v1-protocol.h \
 	pointer-constraints-unstable-v1-protocol.h wlr-layer-shell-unstable-v1-protocol.h \
-	wlr-output-power-management-unstable-v1-protocol.h xdg-shell-protocol.h
+	wlr-output-power-management-unstable-v1-protocol.h xdg-shell-protocol.h \
+	dwl-ipc-unstable-v2-protocol.h
 util.o: util.c util.h
+dwl-ipc-unstable-v2-protocol.o: dwl-ipc-unstable-v2-protocol.c dwl-ipc-unstable-v2-protocol.h
 
 # wayland-scanner is a tool which generates C headers and rigging for Wayland
 # protocols, which are specified in XML. wlroots requires you to rig these up
@@ -45,6 +47,12 @@ wlr-output-power-management-unstable-v1-protocol.h:
 xdg-shell-protocol.h:
 	$(WAYLAND_SCANNER) server-header \
 		$(WAYLAND_PROTOCOLS)/stable/xdg-shell/xdg-shell.xml $@
+dwl-ipc-unstable-v2-protocol.h:
+	$(WAYLAND_SCANNER) server-header \
+		protocols/dwl-ipc-unstable-v2.xml $@
+dwl-ipc-unstable-v2-protocol.c:
+	$(WAYLAND_SCANNER) private-code \
+		protocols/dwl-ipc-unstable-v2.xml $@
 
 config.h:
 	cp config.def.h $@
diff --git a/compile_commands.json b/compile_commands.json
new file mode 100644
index 0000000..26edff6
--- /dev/null
+++ b/compile_commands.json
@@ -0,0 +1,37 @@
+[
+  {
+    "arguments": [
+      "/usr/bin/gcc",
+      "-I/usr/include/wlroots-0.18",
+      "-I/usr/include/libdrm",
+      "-I/usr/include/pixman-1",
+      "-I/usr/lib64/libffi/include",
+      "-I.",
+      "-DWLR_USE_UNSTABLE",
+      "-D_POSIX_C_SOURCE=200809L",
+      "-DVERSION=\"v0.7-dirty\"",
+      "-DXWAYLAND",
+      "-g",
+      "-pedantic",
+      "-Wall",
+      "-Wextra",
+      "-Wdeclaration-after-statement",
+      "-Wno-unused-parameter",
+      "-Wshadow",
+      "-Wunused-macros",
+      "-Werror=strict-prototypes",
+      "-Werror=implicit",
+      "-Werror=return-type",
+      "-Werror=incompatible-pointer-types",
+      "-Wfloat-conversion",
+      "-O1",
+      "-c",
+      "-o",
+      "dwl.o",
+      "dwl.c"
+    ],
+    "directory": "/home/carlos/repos/dwl",
+    "file": "/home/carlos/repos/dwl/dwl.c",
+    "output": "/home/carlos/repos/dwl/dwl.o"
+  }
+]
diff --git a/config.def.h b/config.def.h
index 22d2171..1593033 100644
--- a/config.def.h
+++ b/config.def.h
@@ -127,6 +127,7 @@ static const Key keys[] = {
 	/* modifier                  key                 function        argument */
 	{ MODKEY,                    XKB_KEY_p,          spawn,          {.v = menucmd} },
 	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Return,     spawn,          {.v = termcmd} },
+	{ MODKEY,                    XKB_KEY_b,          togglebar,      {0} },
 	{ MODKEY,                    XKB_KEY_j,          focusstack,     {.i = +1} },
 	{ MODKEY,                    XKB_KEY_k,          focusstack,     {.i = -1} },
 	{ MODKEY,                    XKB_KEY_i,          incnmaster,     {.i = +1} },
diff --git a/config.mk b/config.mk
index 1e0b810..153e80d 100644
--- a/config.mk
+++ b/config.mk
@@ -8,10 +8,10 @@ PREFIX = /usr/local
 MANDIR = $(PREFIX)/share/man
 DATADIR = $(PREFIX)/share
 
-XWAYLAND =
-XLIBS =
+#XWAYLAND =
+#XLIBS =
 # Uncomment to build XWayland support
-#XWAYLAND = -DXWAYLAND
-#XLIBS = xcb xcb-icccm
+XWAYLAND = -DXWAYLAND
+XLIBS = xcb xcb-icccm
 
 CC = gcc
diff --git a/configclangd.h b/configclangd.h
new file mode 100644
index 0000000..8f008fc
--- /dev/null
+++ b/configclangd.h
@@ -0,0 +1,605 @@
+/*
+ * See LICENSE file for copyright and license details.
+ */
+#include <getopt.h>
+#include <libinput.h>
+#include <linux/input-event-codes.h>
+#include <math.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/wait.h>
+#include <time.h>
+#include <unistd.h>
+#include <wayland-server-core.h>
+#include <wlr/backend.h>
+#include <wlr/backend/libinput.h>
+#include <wlr/render/allocator.h>
+#include <wlr/render/wlr_renderer.h>
+#include <wlr/types/wlr_alpha_modifier_v1.h>
+#include <wlr/types/wlr_compositor.h>
+#include <wlr/types/wlr_cursor.h>
+#include <wlr/types/wlr_cursor_shape_v1.h>
+#include <wlr/types/wlr_data_control_v1.h>
+#include <wlr/types/wlr_data_device.h>
+#include <wlr/types/wlr_drm.h>
+#include <wlr/types/wlr_export_dmabuf_v1.h>
+#include <wlr/types/wlr_fractional_scale_v1.h>
+#include <wlr/types/wlr_gamma_control_v1.h>
+#include <wlr/types/wlr_idle_inhibit_v1.h>
+#include <wlr/types/wlr_idle_notify_v1.h>
+#include <wlr/types/wlr_input_device.h>
+#include <wlr/types/wlr_keyboard.h>
+#include <wlr/types/wlr_keyboard_group.h>
+#include <wlr/types/wlr_layer_shell_v1.h>
+#include <wlr/types/wlr_linux_dmabuf_v1.h>
+#include <wlr/types/wlr_output.h>
+#include <wlr/types/wlr_output_layout.h>
+#include <wlr/types/wlr_output_management_v1.h>
+#include <wlr/types/wlr_output_power_management_v1.h>
+#include <wlr/types/wlr_pointer.h>
+#include <wlr/types/wlr_pointer_constraints_v1.h>
+#include <wlr/types/wlr_presentation_time.h>
+#include <wlr/types/wlr_primary_selection.h>
+#include <wlr/types/wlr_primary_selection_v1.h>
+#include <wlr/types/wlr_relative_pointer_v1.h>
+#include <wlr/types/wlr_scene.h>
+#include <wlr/types/wlr_screencopy_v1.h>
+#include <wlr/types/wlr_seat.h>
+#include <wlr/types/wlr_server_decoration.h>
+#include <wlr/types/wlr_session_lock_v1.h>
+#include <wlr/types/wlr_single_pixel_buffer_v1.h>
+#include <wlr/types/wlr_subcompositor.h>
+#include <wlr/types/wlr_viewporter.h>
+#include <wlr/types/wlr_virtual_keyboard_v1.h>
+#include <wlr/types/wlr_virtual_pointer_v1.h>
+#include <wlr/types/wlr_xcursor_manager.h>
+#include <wlr/types/wlr_xdg_activation_v1.h>
+#include <wlr/types/wlr_xdg_decoration_v1.h>
+#include <wlr/types/wlr_xdg_output_v1.h>
+#include <wlr/types/wlr_xdg_shell.h>
+#include <wlr/util/log.h>
+#include <wlr/util/region.h>
+#include <xkbcommon/xkbcommon.h>
+#ifdef XWAYLAND
+#include <wlr/xwayland.h>
+#include <xcb/xcb.h>
+#include <xcb/xcb_icccm.h>
+#endif
+
+#include "util.h"
+
+/* macros */
+#define MAX(A, B)               ((A) > (B) ? (A) : (B))
+#define MIN(A, B)               ((A) < (B) ? (A) : (B))
+#define CLEANMASK(mask)         (mask & ~WLR_MODIFIER_CAPS)
+#define VISIBLEON(C, M)         ((M) && (C)->mon == (M) && ((C)->tags & (M)->tagset[(M)->seltags]))
+#define LENGTH(X)               (sizeof X / sizeof X[0])
+#define END(A)                  ((A) + LENGTH(A))
+#define TAGMASK                 ((1u << TAGCOUNT) - 1)
+#define LISTEN(E, L, H)         wl_signal_add((E), ((L)->notify = (H), (L)))
+#define LISTEN_STATIC(E, H)     do { static struct wl_listener _l = {.notify = (H)}; wl_signal_add((E), &_l); } while (0)
+
+/* enums */
+enum { CurNormal, CurPressed, CurMove, CurResize }; /* cursor */
+enum { XDGShell, LayerShell, X11 }; /* client types */
+enum { LyrBg, LyrBottom, LyrTile, LyrFloat, LyrTop, LyrFS, LyrOverlay, LyrBlock, NUM_LAYERS }; /* scene layers */
+#ifdef XWAYLAND
+enum { NetWMWindowTypeDialog, NetWMWindowTypeSplash, NetWMWindowTypeToolbar,
+	NetWMWindowTypeUtility, NetLast }; /* EWMH atoms */
+#endif
+
+typedef union {
+	int i;
+	uint32_t ui;
+	float f;
+	const void *v;
+} Arg;
+
+typedef struct {
+	unsigned int mod;
+	unsigned int button;
+	void (*func)(const Arg *);
+	const Arg arg;
+} Button;
+
+typedef struct Monitor Monitor;
+typedef struct {
+	/* Must keep these three elements in this order */
+	unsigned int type; /* XDGShell or X11* */
+	struct wlr_box geom; /* layout-relative, includes border */
+	Monitor *mon;
+	struct wlr_scene_tree *scene;
+	struct wlr_scene_rect *border[4]; /* top, bottom, left, right */
+	struct wlr_scene_tree *scene_surface;
+	struct wl_list link;
+	struct wl_list flink;
+	union {
+		struct wlr_xdg_surface *xdg;
+		struct wlr_xwayland_surface *xwayland;
+	} surface;
+	struct wlr_xdg_toplevel_decoration_v1 *decoration;
+	struct wl_listener commit;
+	struct wl_listener map;
+	struct wl_listener maximize;
+	struct wl_listener unmap;
+	struct wl_listener destroy;
+	struct wl_listener set_title;
+	struct wl_listener fullscreen;
+	struct wl_listener set_decoration_mode;
+	struct wl_listener destroy_decoration;
+	struct wlr_box prev; /* layout-relative, includes border */
+	struct wlr_box bounds;
+#ifdef XWAYLAND
+	struct wl_listener activate;
+	struct wl_listener associate;
+	struct wl_listener dissociate;
+	struct wl_listener configure;
+	struct wl_listener set_hints;
+#endif
+	unsigned int bw;
+	uint32_t tags;
+	int isfloating, isurgent, isfullscreen;
+	uint32_t resize; /* configure serial of a pending resize */
+} Client;
+
+typedef struct {
+	uint32_t mod;
+	xkb_keysym_t keysym;
+	void (*func)(const Arg *);
+	const Arg arg;
+} Key;
+
+typedef struct {
+	struct wl_list link;
+	struct wlr_keyboard_group *wlr_group;
+
+	int nsyms;
+	const xkb_keysym_t *keysyms; /* invalid if nsyms == 0 */
+	uint32_t mods; /* invalid if nsyms == 0 */
+	struct wl_event_source *key_repeat_source;
+
+	struct wl_listener modifiers;
+	struct wl_listener key;
+	struct wl_listener destroy;
+} KeyboardGroup;
+
+typedef struct {
+	/* Must keep these three elements in this order */
+	unsigned int type; /* LayerShell */
+	struct wlr_box geom;
+	Monitor *mon;
+	struct wlr_scene_tree *scene;
+	struct wlr_scene_tree *popups;
+	struct wlr_scene_layer_surface_v1 *scene_layer;
+	struct wl_list link;
+	int mapped;
+	struct wlr_layer_surface_v1 *layer_surface;
+
+	struct wl_listener destroy;
+	struct wl_listener unmap;
+	struct wl_listener surface_commit;
+} LayerSurface;
+
+typedef struct {
+	const char *symbol;
+	void (*arrange)(Monitor *);
+} Layout;
+
+struct Monitor {
+	struct wl_list link;
+	struct wlr_output *wlr_output;
+	struct wlr_scene_output *scene_output;
+	struct wlr_scene_rect *fullscreen_bg; /* See createmon() for info */
+	struct wl_listener frame;
+	struct wl_listener destroy;
+	struct wl_listener request_state;
+	struct wl_listener destroy_lock_surface;
+	struct wlr_session_lock_surface_v1 *lock_surface;
+	struct wlr_box m; /* monitor area, layout-relative */
+	struct wlr_box w; /* window area, layout-relative */
+	struct wl_list layers[4]; /* LayerSurface.link */
+	const Layout *lt[2];
+	unsigned int seltags;
+	unsigned int sellt;
+	uint32_t tagset[2];
+	float mfact;
+	int gamma_lut_changed;
+	int nmaster;
+	char ltsymbol[16];
+	int asleep;
+};
+
+typedef struct {
+	const char *name;
+	float mfact;
+	int nmaster;
+	float scale;
+	const Layout *lt;
+	enum wl_output_transform rr;
+	int x, y;
+} MonitorRule;
+
+typedef struct {
+	struct wlr_pointer_constraint_v1 *constraint;
+	struct wl_listener destroy;
+} PointerConstraint;
+
+typedef struct {
+	const char *id;
+	const char *title;
+	uint32_t tags;
+	int isfloating;
+	int monitor;
+} Rule;
+
+typedef struct {
+	struct wlr_scene_tree *scene;
+
+	struct wlr_session_lock_v1 *lock;
+	struct wl_listener new_surface;
+	struct wl_listener unlock;
+	struct wl_listener destroy;
+} SessionLock;
+
+/* function declarations */
+static void applybounds(Client *c, struct wlr_box *bbox);
+static void applyrules(Client *c);
+static void arrange(Monitor *m);
+static void arrangelayer(Monitor *m, struct wl_list *list,
+		struct wlr_box *usable_area, int exclusive);
+static void arrangelayers(Monitor *m);
+static void axisnotify(struct wl_listener *listener, void *data);
+static void buttonpress(struct wl_listener *listener, void *data);
+static void chvt(const Arg *arg);
+static void checkidleinhibitor(struct wlr_surface *exclude);
+static void cleanup(void);
+static void cleanupmon(struct wl_listener *listener, void *data);
+static void closemon(Monitor *m);
+static void commitlayersurfacenotify(struct wl_listener *listener, void *data);
+static void commitnotify(struct wl_listener *listener, void *data);
+static void commitpopup(struct wl_listener *listener, void *data);
+static void createdecoration(struct wl_listener *listener, void *data);
+static void createidleinhibitor(struct wl_listener *listener, void *data);
+static void createkeyboard(struct wlr_keyboard *keyboard);
+static KeyboardGroup *createkeyboardgroup(void);
+static void createlayersurface(struct wl_listener *listener, void *data);
+static void createlocksurface(struct wl_listener *listener, void *data);
+static void createmon(struct wl_listener *listener, void *data);
+static void createnotify(struct wl_listener *listener, void *data);
+static void createpointer(struct wlr_pointer *pointer);
+static void createpointerconstraint(struct wl_listener *listener, void *data);
+static void createpopup(struct wl_listener *listener, void *data);
+static void cursorconstrain(struct wlr_pointer_constraint_v1 *constraint);
+static void cursorframe(struct wl_listener *listener, void *data);
+static void cursorwarptohint(void);
+static void destroydecoration(struct wl_listener *listener, void *data);
+static void destroydragicon(struct wl_listener *listener, void *data);
+static void destroyidleinhibitor(struct wl_listener *listener, void *data);
+static void destroylayersurfacenotify(struct wl_listener *listener, void *data);
+static void destroylock(SessionLock *lock, int unlocked);
+static void destroylocksurface(struct wl_listener *listener, void *data);
+static void destroynotify(struct wl_listener *listener, void *data);
+static void destroypointerconstraint(struct wl_listener *listener, void *data);
+static void destroysessionlock(struct wl_listener *listener, void *data);
+static void destroysessionmgr(struct wl_listener *listener, void *data);
+static void destroykeyboardgroup(struct wl_listener *listener, void *data);
+static Monitor *dirtomon(enum wlr_direction dir);
+static void focusclient(Client *c, int lift);
+static void focusmon(const Arg *arg);
+static void focusstack(const Arg *arg);
+static Client *focustop(Monitor *m);
+static void fullscreennotify(struct wl_listener *listener, void *data);
+static void gpureset(struct wl_listener *listener, void *data);
+static void handlesig(int signo);
+static void incnmaster(const Arg *arg);
+static void inputdevice(struct wl_listener *listener, void *data);
+static int keybinding(uint32_t mods, xkb_keysym_t sym);
+static void keypress(struct wl_listener *listener, void *data);
+static void keypressmod(struct wl_listener *listener, void *data);
+static int keyrepeat(void *data);
+static void killclient(const Arg *arg);
+static void locksession(struct wl_listener *listener, void *data);
+static void mapnotify(struct wl_listener *listener, void *data);
+static void maximizenotify(struct wl_listener *listener, void *data);
+static void monocle(Monitor *m);
+static void motionabsolute(struct wl_listener *listener, void *data);
+static void motionnotify(uint32_t time, struct wlr_input_device *device, double sx,
+		double sy, double sx_unaccel, double sy_unaccel);
+static void motionrelative(struct wl_listener *listener, void *data);
+static void moveresize(const Arg *arg);
+static void outputmgrapply(struct wl_listener *listener, void *data);
+static void outputmgrapplyortest(struct wlr_output_configuration_v1 *config, int test);
+static void outputmgrtest(struct wl_listener *listener, void *data);
+static void pointerfocus(Client *c, struct wlr_surface *surface,
+		double sx, double sy, uint32_t time);
+static void printstatus(void);
+static void powermgrsetmode(struct wl_listener *listener, void *data);
+static void quit(const Arg *arg);
+static void rendermon(struct wl_listener *listener, void *data);
+static void requestdecorationmode(struct wl_listener *listener, void *data);
+static void requeststartdrag(struct wl_listener *listener, void *data);
+static void requestmonstate(struct wl_listener *listener, void *data);
+static void resize(Client *c, struct wlr_box geo, int interact);
+static void run(char *startup_cmd);
+static void setcursor(struct wl_listener *listener, void *data);
+static void setcursorshape(struct wl_listener *listener, void *data);
+static void setfloating(Client *c, int floating);
+static void setfullscreen(Client *c, int fullscreen);
+static void setgamma(struct wl_listener *listener, void *data);
+static void setlayout(const Arg *arg);
+static void setmfact(const Arg *arg);
+static void setmon(Client *c, Monitor *m, uint32_t newtags);
+static void setpsel(struct wl_listener *listener, void *data);
+static void setsel(struct wl_listener *listener, void *data);
+static void setup(void);
+static void spawn(const Arg *arg);
+static void startdrag(struct wl_listener *listener, void *data);
+static void tag(const Arg *arg);
+static void tagmon(const Arg *arg);
+static void tile(Monitor *m);
+static void togglefloating(const Arg *arg);
+static void togglefullscreen(const Arg *arg);
+static void toggletag(const Arg *arg);
+static void toggleview(const Arg *arg);
+static void unlocksession(struct wl_listener *listener, void *data);
+static void unmaplayersurfacenotify(struct wl_listener *listener, void *data);
+static void unmapnotify(struct wl_listener *listener, void *data);
+static void updatemons(struct wl_listener *listener, void *data);
+static void updatetitle(struct wl_listener *listener, void *data);
+static void urgent(struct wl_listener *listener, void *data);
+static void view(const Arg *arg);
+static void virtualkeyboard(struct wl_listener *listener, void *data);
+static void virtualpointer(struct wl_listener *listener, void *data);
+static Monitor *xytomon(double x, double y);
+static void xytonode(double x, double y, struct wlr_surface **psurface,
+		Client **pc, LayerSurface **pl, double *nx, double *ny);
+static void zoom(const Arg *arg);
+
+/* variables */
+static const char broken[] = "broken";
+static pid_t child_pid = -1;
+static int locked;
+static void *exclusive_focus;
+static struct wl_display *dpy;
+static struct wl_event_loop *event_loop;
+static struct wlr_backend *backend;
+static struct wlr_scene *scene;
+static struct wlr_scene_tree *layers[NUM_LAYERS];
+static struct wlr_scene_tree *drag_icon;
+/* Map from ZWLR_LAYER_SHELL_* constants to Lyr* enum */
+static const int layermap[] = { LyrBg, LyrBottom, LyrTop, LyrOverlay };
+static struct wlr_renderer *drw;
+static struct wlr_allocator *alloc;
+static struct wlr_compositor *compositor;
+static struct wlr_session *session;
+
+static struct wlr_xdg_shell *xdg_shell;
+static struct wlr_xdg_activation_v1 *activation;
+static struct wlr_xdg_decoration_manager_v1 *xdg_decoration_mgr;
+static struct wl_list clients; /* tiling order */
+static struct wl_list fstack;  /* focus order */
+static struct wlr_idle_notifier_v1 *idle_notifier;
+static struct wlr_idle_inhibit_manager_v1 *idle_inhibit_mgr;
+static struct wlr_layer_shell_v1 *layer_shell;
+static struct wlr_output_manager_v1 *output_mgr;
+static struct wlr_gamma_control_manager_v1 *gamma_control_mgr;
+static struct wlr_virtual_keyboard_manager_v1 *virtual_keyboard_mgr;
+static struct wlr_virtual_pointer_manager_v1 *virtual_pointer_mgr;
+static struct wlr_cursor_shape_manager_v1 *cursor_shape_mgr;
+static struct wlr_output_power_manager_v1 *power_mgr;
+
+static struct wlr_pointer_constraints_v1 *pointer_constraints;
+static struct wlr_relative_pointer_manager_v1 *relative_pointer_mgr;
+static struct wlr_pointer_constraint_v1 *active_constraint;
+
+static struct wlr_cursor *cursor;
+static struct wlr_xcursor_manager *cursor_mgr;
+
+static struct wlr_scene_rect *root_bg;
+static struct wlr_session_lock_manager_v1 *session_lock_mgr;
+static struct wlr_scene_rect *locked_bg;
+static struct wlr_session_lock_v1 *cur_lock;
+static struct wl_listener lock_listener = {.notify = locksession};
+
+static struct wlr_seat *seat;
+static KeyboardGroup *kb_group;
+static unsigned int cursor_mode;
+static Client *grabc;
+static int grabcx, grabcy; /* client-relative */
+
+static struct wlr_output_layout *output_layout;
+static struct wlr_box sgeom;
+static struct wl_list mons;
+static Monitor *selmon;
+
+#ifdef XWAYLAND
+static void activatex11(struct wl_listener *listener, void *data);
+static void associatex11(struct wl_listener *listener, void *data);
+static void configurex11(struct wl_listener *listener, void *data);
+static void createnotifyx11(struct wl_listener *listener, void *data);
+static void dissociatex11(struct wl_listener *listener, void *data);
+static xcb_atom_t getatom(xcb_connection_t *xc, const char *name);
+static void sethints(struct wl_listener *listener, void *data);
+static void xwaylandready(struct wl_listener *listener, void *data);
+static struct wlr_xwayland *xwayland;
+static xcb_atom_t netatom[NetLast];
+#endif
+
+/* configuration, allows nested code to access above variables */
+/* Taken from https://github.com/djpohly/dwl/issues/466 */
+#define COLOR(hex)    { ((hex >> 24) & 0xFF) / 255.0f, \
+                        ((hex >> 16) & 0xFF) / 255.0f, \
+                        ((hex >> 8) & 0xFF) / 255.0f, \
+                        (hex & 0xFF) / 255.0f }
+/* appearance */
+static const int sloppyfocus               = 1;  /* focus follows mouse */
+static const int bypass_surface_visibility = 0;  /* 1 means idle inhibitors will disable idle tracking even if it's surface isn't visible  */
+static const unsigned int borderpx         = 1;  /* border pixel of windows */
+static const float rootcolor[]             = COLOR(0x222222ff);
+static const float bordercolor[]           = COLOR(0x444444ff);
+static const float focuscolor[]            = COLOR(0x005577ff);
+static const float urgentcolor[]           = COLOR(0xff0000ff);
+/* This conforms to the xdg-protocol. Set the alpha to zero to restore the old behavior */
+static const float fullscreen_bg[]         = {0.1f, 0.1f, 0.1f, 1.0f}; /* You can also use glsl colors */
+
+/* tagging - TAGCOUNT must be no greater than 31 */
+#define TAGCOUNT (9)
+
+/* logging */
+static int log_level = WLR_ERROR;
+
+/* NOTE: ALWAYS keep a rule declared even if you don't use rules (e.g leave at least one example) */
+static const Rule rules[] = {
+	/* app_id             title       tags mask     isfloating   monitor */
+	/* examples: */
+	{ "Gimp_EXAMPLE",     NULL,       0,            1,           -1 }, /* Start on currently visible tags floating, not tiled */
+	{ "firefox_EXAMPLE",  NULL,       1 << 8,       0,           -1 }, /* Start on ONLY tag "9" */
+};
+
+/* layout(s) */
+static const Layout layouts[] = {
+	/* symbol     arrange function */
+	{ "[]=",      tile },
+	{ "><>",      NULL },    /* no layout function means floating behavior */
+	{ "[M]",      monocle },
+};
+
+/* monitors */
+/* (x=-1, y=-1) is reserved as an "autoconfigure" monitor position indicator
+ * WARNING: negative values other than (-1, -1) cause problems with Xwayland clients
+ * https://gitlab.freedesktop.org/xorg/xserver/-/issues/899
+*/
+/* NOTE: ALWAYS add a fallback rule, even if you are completely sure it won't be used */
+static const MonitorRule monrules[] = {
+	/* name       mfact  nmaster scale layout       rotate/reflect                x    y */
+	/* example of a HiDPI laptop monitor:
+	{ "eDP-1",    0.5f,  1,      2,    &layouts[0], WL_OUTPUT_TRANSFORM_NORMAL,   -1,  -1 },
+	*/
+	/* defaults */
+	{ NULL,       0.55f, 1,      1,    &layouts[0], WL_OUTPUT_TRANSFORM_NORMAL,   -1,  -1 },
+};
+
+/* keyboard */
+static const struct xkb_rule_names xkb_rules = {
+	/* can specify fields: rules, model, layout, variant, options */
+	/* example:
+	.options = "ctrl:nocaps",
+	*/
+	.options = NULL,
+};
+
+static const int repeat_rate = 25;
+static const int repeat_delay = 600;
+
+/* Trackpad */
+static const int tap_to_click = 1;
+static const int tap_and_drag = 1;
+static const int drag_lock = 1;
+static const int natural_scrolling = 0;
+static const int disable_while_typing = 1;
+static const int left_handed = 0;
+static const int middle_button_emulation = 0;
+/* You can choose between:
+LIBINPUT_CONFIG_SCROLL_NO_SCROLL
+LIBINPUT_CONFIG_SCROLL_2FG
+LIBINPUT_CONFIG_SCROLL_EDGE
+LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN
+*/
+static const enum libinput_config_scroll_method scroll_method = LIBINPUT_CONFIG_SCROLL_2FG;
+
+/* You can choose between:
+LIBINPUT_CONFIG_CLICK_METHOD_NONE
+LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS
+LIBINPUT_CONFIG_CLICK_METHOD_CLICKFINGER
+*/
+static const enum libinput_config_click_method click_method = LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS;
+
+/* You can choose between:
+LIBINPUT_CONFIG_SEND_EVENTS_ENABLED
+LIBINPUT_CONFIG_SEND_EVENTS_DISABLED
+LIBINPUT_CONFIG_SEND_EVENTS_DISABLED_ON_EXTERNAL_MOUSE
+*/
+static const uint32_t send_events_mode = LIBINPUT_CONFIG_SEND_EVENTS_ENABLED;
+
+/* You can choose between:
+LIBINPUT_CONFIG_ACCEL_PROFILE_FLAT
+LIBINPUT_CONFIG_ACCEL_PROFILE_ADAPTIVE
+*/
+static const enum libinput_config_accel_profile accel_profile = LIBINPUT_CONFIG_ACCEL_PROFILE_ADAPTIVE;
+static const double accel_speed = 0.0;
+
+/* You can choose between:
+LIBINPUT_CONFIG_TAP_MAP_LRM -- 1/2/3 finger tap maps to left/right/middle
+LIBINPUT_CONFIG_TAP_MAP_LMR -- 1/2/3 finger tap maps to left/middle/right
+*/
+static const enum libinput_config_tap_button_map button_map = LIBINPUT_CONFIG_TAP_MAP_LRM;
+
+/* If you want to use the windows key for MODKEY, use WLR_MODIFIER_LOGO */
+#define MODKEY WLR_MODIFIER_ALT
+
+#define TAGKEYS(KEY,SKEY,TAG) \
+	{ MODKEY,                    KEY,            view,            {.ui = 1 << TAG} }, \
+	{ MODKEY|WLR_MODIFIER_CTRL,  KEY,            toggleview,      {.ui = 1 << TAG} }, \
+	{ MODKEY|WLR_MODIFIER_SHIFT, SKEY,           tag,             {.ui = 1 << TAG} }, \
+	{ MODKEY|WLR_MODIFIER_CTRL|WLR_MODIFIER_SHIFT,SKEY,toggletag, {.ui = 1 << TAG} }
+
+/* helper for spawning shell commands in the pre dwm-5.0 fashion */
+#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+
+/* commands */
+static const char *termcmd[] = { "foot", NULL };
+static const char *menucmd[] = { "wmenu-run", NULL };
+
+static const Key keys[] = {
+	/* Note that Shift changes certain key codes: c -> C, 2 -> at, etc. */
+	/* modifier                  key                 function        argument */
+	{ MODKEY,                    XKB_KEY_p,          spawn,          {.v = menucmd} },
+	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Return,     spawn,          {.v = termcmd} },
+	{ MODKEY,                    XKB_KEY_j,          focusstack,     {.i = +1} },
+	{ MODKEY,                    XKB_KEY_k,          focusstack,     {.i = -1} },
+	{ MODKEY,                    XKB_KEY_i,          incnmaster,     {.i = +1} },
+	{ MODKEY,                    XKB_KEY_d,          incnmaster,     {.i = -1} },
+	{ MODKEY,                    XKB_KEY_h,          setmfact,       {.f = -0.05f} },
+	{ MODKEY,                    XKB_KEY_l,          setmfact,       {.f = +0.05f} },
+	{ MODKEY,                    XKB_KEY_Return,     zoom,           {0} },
+	{ MODKEY,                    XKB_KEY_Tab,        view,           {0} },
+	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_C,          killclient,     {0} },
+	{ MODKEY,                    XKB_KEY_t,          setlayout,      {.v = &layouts[0]} },
+	{ MODKEY,                    XKB_KEY_f,          setlayout,      {.v = &layouts[1]} },
+	{ MODKEY,                    XKB_KEY_m,          setlayout,      {.v = &layouts[2]} },
+	{ MODKEY,                    XKB_KEY_space,      setlayout,      {0} },
+	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_space,      togglefloating, {0} },
+	{ MODKEY,                    XKB_KEY_e,         togglefullscreen, {0} },
+	{ MODKEY,                    XKB_KEY_0,          view,           {.ui = ~0} },
+	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_parenright, tag,            {.ui = ~0} },
+	{ MODKEY,                    XKB_KEY_comma,      focusmon,       {.i = WLR_DIRECTION_LEFT} },
+	{ MODKEY,                    XKB_KEY_period,     focusmon,       {.i = WLR_DIRECTION_RIGHT} },
+	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_less,       tagmon,         {.i = WLR_DIRECTION_LEFT} },
+	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_greater,    tagmon,         {.i = WLR_DIRECTION_RIGHT} },
+	TAGKEYS(          XKB_KEY_1, XKB_KEY_exclam,                     0),
+	TAGKEYS(          XKB_KEY_2, XKB_KEY_at,                         1),
+	TAGKEYS(          XKB_KEY_3, XKB_KEY_numbersign,                 2),
+	TAGKEYS(          XKB_KEY_4, XKB_KEY_dollar,                     3),
+	TAGKEYS(          XKB_KEY_5, XKB_KEY_percent,                    4),
+	TAGKEYS(          XKB_KEY_6, XKB_KEY_asciicircum,                5),
+	TAGKEYS(          XKB_KEY_7, XKB_KEY_ampersand,                  6),
+	TAGKEYS(          XKB_KEY_8, XKB_KEY_asterisk,                   7),
+	TAGKEYS(          XKB_KEY_9, XKB_KEY_parenleft,                  8),
+	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Q,          quit,           {0} },
+
+	/* Ctrl-Alt-Backspace and Ctrl-Alt-Fx used to be handled by X server */
+	{ WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_Terminate_Server, quit, {0} },
+	/* Ctrl-Alt-Fx is used to switch to another VT, if you don't know what a VT is
+	 * do not remove them.
+	 */
+#define CHVT(n) { WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_XF86Switch_VT_##n, chvt, {.ui = (n)} }
+	CHVT(1), CHVT(2), CHVT(3), CHVT(4), CHVT(5), CHVT(6),
+	CHVT(7), CHVT(8), CHVT(9), CHVT(10), CHVT(11), CHVT(12),
+};
+
+static const Button buttons[] = {
+	{ MODKEY, BTN_LEFT,   moveresize,     {.ui = CurMove} },
+	{ MODKEY, BTN_MIDDLE, togglefloating, {0} },
+	{ MODKEY, BTN_RIGHT,  moveresize,     {.ui = CurResize} },
+};
diff --git a/dwl.c b/dwl.c
index a2711f6..5e41c52 100644
--- a/dwl.c
+++ b/dwl.c
@@ -67,6 +67,7 @@
 #include <xcb/xcb_icccm.h>
 #endif
 
+#include "dwl-ipc-unstable-v2-protocol.h"
 #include "util.h"
 
 /* macros */
@@ -143,6 +144,12 @@ typedef struct {
 	uint32_t resize; /* configure serial of a pending resize */
 } Client;
 
+typedef struct {
+	struct wl_list link;
+	struct wl_resource *resource;
+	Monitor *mon;
+} DwlIpcOutput;
+
 typedef struct {
 	uint32_t mod;
 	xkb_keysym_t keysym;
@@ -188,6 +195,7 @@ typedef struct {
 
 struct Monitor {
 	struct wl_list link;
+	struct wl_list dwl_ipc_outputs;
 	struct wlr_output *wlr_output;
 	struct wlr_scene_output *scene_output;
 	struct wlr_scene_rect *fullscreen_bg; /* See createmon() for info */
@@ -285,6 +293,17 @@ static void destroysessionlock(struct wl_listener *listener, void *data);
 static void destroysessionmgr(struct wl_listener *listener, void *data);
 static void destroykeyboardgroup(struct wl_listener *listener, void *data);
 static Monitor *dirtomon(enum wlr_direction dir);
+static void dwl_ipc_manager_bind(struct wl_client *client, void *data, uint32_t version, uint32_t id);
+static void dwl_ipc_manager_destroy(struct wl_resource *resource);
+static void dwl_ipc_manager_get_output(struct wl_client *client, struct wl_resource *resource, uint32_t id, struct wl_resource *output);
+static void dwl_ipc_manager_release(struct wl_client *client, struct wl_resource *resource);
+static void dwl_ipc_output_destroy(struct wl_resource *resource);
+static void dwl_ipc_output_printstatus(Monitor *monitor);
+static void dwl_ipc_output_printstatus_to(DwlIpcOutput *ipc_output);
+static void dwl_ipc_output_set_client_tags(struct wl_client *client, struct wl_resource *resource, uint32_t and_tags, uint32_t xor_tags);
+static void dwl_ipc_output_set_layout(struct wl_client *client, struct wl_resource *resource, uint32_t index);
+static void dwl_ipc_output_set_tags(struct wl_client *client, struct wl_resource *resource, uint32_t tagmask, uint32_t toggle_tagset);
+static void dwl_ipc_output_release(struct wl_client *client, struct wl_resource *resource);
 static void focusclient(Client *c, int lift);
 static void focusmon(const Arg *arg);
 static void focusstack(const Arg *arg);
@@ -338,6 +357,7 @@ static void startdrag(struct wl_listener *listener, void *data);
 static void tag(const Arg *arg);
 static void tagmon(const Arg *arg);
 static void tile(Monitor *m);
+static void togglebar(const Arg *arg);
 static void togglefloating(const Arg *arg);
 static void togglefullscreen(const Arg *arg);
 static void toggletag(const Arg *arg);
@@ -413,6 +433,9 @@ static struct wlr_box sgeom;
 static struct wl_list mons;
 static Monitor *selmon;
 
+static struct zdwl_ipc_manager_v2_interface dwl_manager_implementation = {.release = dwl_ipc_manager_release, .get_output = dwl_ipc_manager_get_output};
+static struct zdwl_ipc_output_v2_interface dwl_output_implementation = {.release = dwl_ipc_output_release, .set_tags = dwl_ipc_output_set_tags, .set_layout = dwl_ipc_output_set_layout, .set_client_tags = dwl_ipc_output_set_client_tags};
+
 #ifdef XWAYLAND
 static void activatex11(struct wl_listener *listener, void *data);
 static void associatex11(struct wl_listener *listener, void *data);
@@ -706,6 +729,10 @@ cleanupmon(struct wl_listener *listener, void *data)
 	LayerSurface *l, *tmp;
 	size_t i;
 
+	DwlIpcOutput *ipc_output, *ipc_output_tmp;
+	wl_list_for_each_safe(ipc_output, ipc_output_tmp, &m->dwl_ipc_outputs, link)
+		wl_resource_destroy(ipc_output->resource);
+
 	/* m->layers[i] are intentionally not unlinked */
 	for (i = 0; i < LENGTH(m->layers); i++) {
 		wl_list_for_each_safe(l, tmp, &m->layers[i], link)
@@ -986,6 +1013,8 @@ createmon(struct wl_listener *listener, void *data)
 	m = wlr_output->data = ecalloc(1, sizeof(*m));
 	m->wlr_output = wlr_output;
 
+	wl_list_init(&m->dwl_ipc_outputs);
+
 	for (i = 0; i < LENGTH(m->layers); i++)
 		wl_list_init(&m->layers[i]);
 
@@ -1336,6 +1365,192 @@ dirtomon(enum wlr_direction dir)
 	return selmon;
 }
 
+void
+dwl_ipc_manager_bind(struct wl_client *client, void *data, uint32_t version, uint32_t id)
+{
+	struct wl_resource *manager_resource = wl_resource_create(client, &zdwl_ipc_manager_v2_interface, version, id);
+	if (!manager_resource) {
+		wl_client_post_no_memory(client);
+		return;
+	}
+	wl_resource_set_implementation(manager_resource, &dwl_manager_implementation, NULL, dwl_ipc_manager_destroy);
+
+	zdwl_ipc_manager_v2_send_tags(manager_resource, TAGCOUNT);
+
+	for (unsigned int i = 0; i < LENGTH(layouts); i++)
+		zdwl_ipc_manager_v2_send_layout(manager_resource, layouts[i].symbol);
+}
+
+void
+dwl_ipc_manager_destroy(struct wl_resource *resource)
+{
+	/* No state to destroy */
+}
+
+void
+dwl_ipc_manager_get_output(struct wl_client *client, struct wl_resource *resource, uint32_t id, struct wl_resource *output)
+{
+	DwlIpcOutput *ipc_output;
+	Monitor *monitor = wlr_output_from_resource(output)->data;
+	struct wl_resource *output_resource = wl_resource_create(client, &zdwl_ipc_output_v2_interface, wl_resource_get_version(resource), id);
+	if (!output_resource)
+		return;
+
+	ipc_output = ecalloc(1, sizeof(*ipc_output));
+	ipc_output->resource = output_resource;
+	ipc_output->mon = monitor;
+	wl_resource_set_implementation(output_resource, &dwl_output_implementation, ipc_output, dwl_ipc_output_destroy);
+	wl_list_insert(&monitor->dwl_ipc_outputs, &ipc_output->link);
+	dwl_ipc_output_printstatus_to(ipc_output);
+}
+
+void
+dwl_ipc_manager_release(struct wl_client *client, struct wl_resource *resource)
+{
+	wl_resource_destroy(resource);
+}
+
+static void
+dwl_ipc_output_destroy(struct wl_resource *resource)
+{
+	DwlIpcOutput *ipc_output = wl_resource_get_user_data(resource);
+	wl_list_remove(&ipc_output->link);
+	free(ipc_output);
+}
+
+void
+dwl_ipc_output_printstatus(Monitor *monitor)
+{
+	DwlIpcOutput *ipc_output;
+	wl_list_for_each(ipc_output, &monitor->dwl_ipc_outputs, link)
+		dwl_ipc_output_printstatus_to(ipc_output);
+}
+
+void
+dwl_ipc_output_printstatus_to(DwlIpcOutput *ipc_output)
+{
+	Monitor *monitor = ipc_output->mon;
+	Client *c, *focused;
+	int tagmask, state, numclients, focused_client, tag;
+	const char *title, *appid;
+	focused = focustop(monitor);
+	zdwl_ipc_output_v2_send_active(ipc_output->resource, monitor == selmon);
+
+	for (tag = 0 ; tag < TAGCOUNT; tag++) {
+		numclients = state = focused_client = 0;
+		tagmask = 1 << tag;
+		if ((tagmask & monitor->tagset[monitor->seltags]) != 0)
+			state |= ZDWL_IPC_OUTPUT_V2_TAG_STATE_ACTIVE;
+
+		wl_list_for_each(c, &clients, link) {
+			if (c->mon != monitor)
+				continue;
+			if (!(c->tags & tagmask))
+				continue;
+			if (c == focused)
+				focused_client = 1;
+			if (c->isurgent)
+				state |= ZDWL_IPC_OUTPUT_V2_TAG_STATE_URGENT;
+
+			numclients++;
+		}
+		zdwl_ipc_output_v2_send_tag(ipc_output->resource, tag, state, numclients, focused_client);
+	}
+	title = focused ? client_get_title(focused) : "";
+	appid = focused ? client_get_appid(focused) : "";
+
+	zdwl_ipc_output_v2_send_layout(ipc_output->resource, monitor->lt[monitor->sellt] - layouts);
+	zdwl_ipc_output_v2_send_title(ipc_output->resource, title);
+	zdwl_ipc_output_v2_send_appid(ipc_output->resource, appid);
+	zdwl_ipc_output_v2_send_layout_symbol(ipc_output->resource, monitor->ltsymbol);
+	if (wl_resource_get_version(ipc_output->resource) >= ZDWL_IPC_OUTPUT_V2_FULLSCREEN_SINCE_VERSION) {
+		zdwl_ipc_output_v2_send_fullscreen(ipc_output->resource, focused ? focused->isfullscreen : 0);
+	}
+	if (wl_resource_get_version(ipc_output->resource) >= ZDWL_IPC_OUTPUT_V2_FLOATING_SINCE_VERSION) {
+		zdwl_ipc_output_v2_send_floating(ipc_output->resource, focused ? focused->isfloating : 0);
+	}
+	zdwl_ipc_output_v2_send_frame(ipc_output->resource);
+}
+
+void
+dwl_ipc_output_set_client_tags(struct wl_client *client, struct wl_resource *resource, uint32_t and_tags, uint32_t xor_tags)
+{
+	DwlIpcOutput *ipc_output;
+	Monitor *monitor;
+	Client *selected_client;
+	unsigned int newtags = 0;
+
+	ipc_output = wl_resource_get_user_data(resource);
+	if (!ipc_output)
+		return;
+
+	monitor = ipc_output->mon;
+	selected_client = focustop(monitor);
+	if (!selected_client)
+		return;
+
+	newtags = (selected_client->tags & and_tags) ^ xor_tags;
+	if (!newtags)
+		return;
+
+	selected_client->tags = newtags;
+	if (selmon == monitor)
+		focusclient(focustop(monitor), 1);
+	arrange(selmon);
+	printstatus();
+}
+
+void
+dwl_ipc_output_set_layout(struct wl_client *client, struct wl_resource *resource, uint32_t index)
+{
+	DwlIpcOutput *ipc_output;
+	Monitor *monitor;
+
+	ipc_output = wl_resource_get_user_data(resource);
+	if (!ipc_output)
+		return;
+
+	monitor = ipc_output->mon;
+	if (index >= LENGTH(layouts))
+		return;
+	if (index != monitor->lt[monitor->sellt] - layouts)
+		monitor->sellt ^= 1;
+
+	monitor->lt[monitor->sellt] = &layouts[index];
+	arrange(monitor);
+	printstatus();
+}
+
+void
+dwl_ipc_output_set_tags(struct wl_client *client, struct wl_resource *resource, uint32_t tagmask, uint32_t toggle_tagset)
+{
+	DwlIpcOutput *ipc_output;
+	Monitor *monitor;
+	unsigned int newtags = tagmask & TAGMASK;
+
+	ipc_output = wl_resource_get_user_data(resource);
+	if (!ipc_output)
+		return;
+	monitor = ipc_output->mon;
+
+	if (!newtags || newtags == monitor->tagset[monitor->seltags])
+		return;
+	if (toggle_tagset)
+		monitor->seltags ^= 1;
+
+	monitor->tagset[monitor->seltags] = newtags;
+	if (selmon == monitor)
+		focusclient(focustop(monitor), 1);
+	arrange(monitor);
+	printstatus();
+}
+
+void
+dwl_ipc_output_release(struct wl_client *client, struct wl_resource *resource)
+{
+	wl_resource_destroy(resource);
+}
+
 void
 focusclient(Client *c, int lift)
 {
@@ -2036,41 +2251,46 @@ void
 printstatus(void)
 {
 	Monitor *m = NULL;
-	Client *c;
-	uint32_t occ, urg, sel;
-	const char *appid, *title;
-
-	wl_list_for_each(m, &mons, link) {
-		occ = urg = 0;
-		wl_list_for_each(c, &clients, link) {
-			if (c->mon != m)
-				continue;
-			occ |= c->tags;
-			if (c->isurgent)
-				urg |= c->tags;
-		}
-		if ((c = focustop(m))) {
-			title = client_get_title(c);
-			appid = client_get_appid(c);
-			printf("%s title %s\n", m->wlr_output->name, title ? title : broken);
-			printf("%s appid %s\n", m->wlr_output->name, appid ? appid : broken);
-			printf("%s fullscreen %d\n", m->wlr_output->name, c->isfullscreen);
-			printf("%s floating %d\n", m->wlr_output->name, c->isfloating);
-			sel = c->tags;
-		} else {
-			printf("%s title \n", m->wlr_output->name);
-			printf("%s appid \n", m->wlr_output->name);
-			printf("%s fullscreen \n", m->wlr_output->name);
-			printf("%s floating \n", m->wlr_output->name);
-			sel = 0;
-		}
-
-		printf("%s selmon %u\n", m->wlr_output->name, m == selmon);
-		printf("%s tags %"PRIu32" %"PRIu32" %"PRIu32" %"PRIu32"\n",
-			m->wlr_output->name, occ, m->tagset[m->seltags], sel, urg);
-		printf("%s layout %s\n", m->wlr_output->name, m->ltsymbol);
-	}
-	fflush(stdout);
+//<<<<<<< HEAD
+//	Client *c;
+//	uint32_t occ, urg, sel;
+//	const char *appid, *title;
+//
+//	wl_list_for_each(m, &mons, link) {
+//		occ = urg = 0;
+//		wl_list_for_each(c, &clients, link) {
+//			if (c->mon != m)
+//				continue;
+//			occ |= c->tags;
+//			if (c->isurgent)
+//				urg |= c->tags;
+//		}
+//		if ((c = focustop(m))) {
+//			title = client_get_title(c);
+//			appid = client_get_appid(c);
+//			printf("%s title %s\n", m->wlr_output->name, title ? title : broken);
+//			printf("%s appid %s\n", m->wlr_output->name, appid ? appid : broken);
+//			printf("%s fullscreen %d\n", m->wlr_output->name, c->isfullscreen);
+//			printf("%s floating %d\n", m->wlr_output->name, c->isfloating);
+//			sel = c->tags;
+//		} else {
+//			printf("%s title \n", m->wlr_output->name);
+//			printf("%s appid \n", m->wlr_output->name);
+//			printf("%s fullscreen \n", m->wlr_output->name);
+//			printf("%s floating \n", m->wlr_output->name);
+//			sel = 0;
+//		}
+//
+//		printf("%s selmon %u\n", m->wlr_output->name, m == selmon);
+//		printf("%s tags %"PRIu32" %"PRIu32" %"PRIu32" %"PRIu32"\n",
+//			m->wlr_output->name, occ, m->tagset[m->seltags], sel, urg);
+//		printf("%s layout %s\n", m->wlr_output->name, m->ltsymbol);
+//	}
+//	fflush(stdout);
+//=======
+
+	wl_list_for_each(m, &mons, link)
+		dwl_ipc_output_printstatus(m);
 }
 
 void
@@ -2625,6 +2845,8 @@ setup(void)
 	LISTEN_STATIC(&output_mgr->events.apply, outputmgrapply);
 	LISTEN_STATIC(&output_mgr->events.test, outputmgrtest);
 
+	wl_global_create(dpy, &zdwl_ipc_manager_v2_interface, 2, NULL, dwl_ipc_manager_bind);
+
 	/* Make sure XWayland clients don't connect to the parent X server,
 	 * e.g when running in the x11 backend or the wayland backend and the
 	 * compositor has Xwayland support */
@@ -2722,6 +2944,13 @@ tile(Monitor *m)
 	}
 }
 
+void
+togglebar(const Arg *arg) {
+	DwlIpcOutput *ipc_output;
+	wl_list_for_each(ipc_output, &selmon->dwl_ipc_outputs, link)
+		zdwl_ipc_output_v2_send_toggle_visibility(ipc_output->resource);
+}
+
 void
 togglefloating(const Arg *arg)
 {
diff --git a/ipc.patch b/ipc.patch
new file mode 100644
index 0000000..9f989e7
--- /dev/null
+++ b/ipc.patch
@@ -0,0 +1,597 @@
+From 6c6d655b68770ce82a24fde9b58c4d97b672553a Mon Sep 17 00:00:00 2001
+From: choc <notchoc@proton.me>
+Date: Mon, 23 Oct 2023 10:35:17 +0800
+Subject: [PATCH] implement dwl-ipc-unstable-v2
+ https://codeberg.org/dwl/dwl-patches/wiki/ipc
+
+---
+ Makefile                          |  14 +-
+ config.def.h                      |   1 +
+ dwl.c                             | 257 ++++++++++++++++++++++++++----
+ protocols/dwl-ipc-unstable-v2.xml | 181 +++++++++++++++++++++
+ 4 files changed, 419 insertions(+), 34 deletions(-)
+ create mode 100644 protocols/dwl-ipc-unstable-v2.xml
+
+diff --git a/Makefile b/Makefile
+index 8db7409..a79a080 100644
+--- a/Makefile
++++ b/Makefile
+@@ -17,12 +17,14 @@ DWLCFLAGS = `$(PKG_CONFIG) --cflags $(PKGS)` $(WLR_INCS) $(DWLCPPFLAGS) $(DWLDEV
+ LDLIBS    = `$(PKG_CONFIG) --libs $(PKGS)` $(WLR_LIBS) -lm $(LIBS)
+ 
+ all: dwl
+-dwl: dwl.o util.o
+-	$(CC) dwl.o util.o $(DWLCFLAGS) $(LDFLAGS) $(LDLIBS) -o $@
++dwl: dwl.o util.o dwl-ipc-unstable-v2-protocol.o
++	$(CC) dwl.o util.o dwl-ipc-unstable-v2-protocol.o $(DWLCFLAGS) $(LDFLAGS) $(LDLIBS) -o $@
+ dwl.o: dwl.c client.h config.h config.mk cursor-shape-v1-protocol.h \
+ 	pointer-constraints-unstable-v1-protocol.h wlr-layer-shell-unstable-v1-protocol.h \
+-	wlr-output-power-management-unstable-v1-protocol.h xdg-shell-protocol.h
++	wlr-output-power-management-unstable-v1-protocol.h xdg-shell-protocol.h \
++	dwl-ipc-unstable-v2-protocol.h
+ util.o: util.c util.h
++dwl-ipc-unstable-v2-protocol.o: dwl-ipc-unstable-v2-protocol.c dwl-ipc-unstable-v2-protocol.h
+ 
+ # wayland-scanner is a tool which generates C headers and rigging for Wayland
+ # protocols, which are specified in XML. wlroots requires you to rig these up
+@@ -45,6 +47,12 @@ wlr-output-power-management-unstable-v1-protocol.h:
+ xdg-shell-protocol.h:
+ 	$(WAYLAND_SCANNER) server-header \
+ 		$(WAYLAND_PROTOCOLS)/stable/xdg-shell/xdg-shell.xml $@
++dwl-ipc-unstable-v2-protocol.h:
++	$(WAYLAND_SCANNER) server-header \
++		protocols/dwl-ipc-unstable-v2.xml $@
++dwl-ipc-unstable-v2-protocol.c:
++	$(WAYLAND_SCANNER) private-code \
++		protocols/dwl-ipc-unstable-v2.xml $@
+ 
+ config.h:
+ 	cp config.def.h $@
+diff --git a/config.def.h b/config.def.h
+index 22d2171..1593033 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -127,6 +127,7 @@ static const Key keys[] = {
+ 	/* modifier                  key                 function        argument */
+ 	{ MODKEY,                    XKB_KEY_p,          spawn,          {.v = menucmd} },
+ 	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Return,     spawn,          {.v = termcmd} },
++	{ MODKEY,                    XKB_KEY_b,          togglebar,      {0} },
+ 	{ MODKEY,                    XKB_KEY_j,          focusstack,     {.i = +1} },
+ 	{ MODKEY,                    XKB_KEY_k,          focusstack,     {.i = -1} },
+ 	{ MODKEY,                    XKB_KEY_i,          incnmaster,     {.i = +1} },
+diff --git a/dwl.c b/dwl.c
+index 8a587d1..7a4949b 100644
+--- a/dwl.c
++++ b/dwl.c
+@@ -68,6 +68,7 @@
+ #include <xcb/xcb_icccm.h>
+ #endif
+ 
++#include "dwl-ipc-unstable-v2-protocol.h"
+ #include "util.h"
+ 
+ /* macros */
+@@ -144,6 +145,12 @@ typedef struct {
+ 	uint32_t resize; /* configure serial of a pending resize */
+ } Client;
+ 
++typedef struct {
++	struct wl_list link;
++	struct wl_resource *resource;
++	Monitor *mon;
++} DwlIpcOutput;
++
+ typedef struct {
+ 	uint32_t mod;
+ 	xkb_keysym_t keysym;
+@@ -189,6 +196,7 @@ typedef struct {
+ 
+ struct Monitor {
+ 	struct wl_list link;
++	struct wl_list dwl_ipc_outputs;
+ 	struct wlr_output *wlr_output;
+ 	struct wlr_scene_output *scene_output;
+ 	struct wlr_scene_rect *fullscreen_bg; /* See createmon() for info */
+@@ -286,6 +294,17 @@ static void destroysessionlock(struct wl_listener *listener, void *data);
+ static void destroysessionmgr(struct wl_listener *listener, void *data);
+ static void destroykeyboardgroup(struct wl_listener *listener, void *data);
+ static Monitor *dirtomon(enum wlr_direction dir);
++static void dwl_ipc_manager_bind(struct wl_client *client, void *data, uint32_t version, uint32_t id);
++static void dwl_ipc_manager_destroy(struct wl_resource *resource);
++static void dwl_ipc_manager_get_output(struct wl_client *client, struct wl_resource *resource, uint32_t id, struct wl_resource *output);
++static void dwl_ipc_manager_release(struct wl_client *client, struct wl_resource *resource);
++static void dwl_ipc_output_destroy(struct wl_resource *resource);
++static void dwl_ipc_output_printstatus(Monitor *monitor);
++static void dwl_ipc_output_printstatus_to(DwlIpcOutput *ipc_output);
++static void dwl_ipc_output_set_client_tags(struct wl_client *client, struct wl_resource *resource, uint32_t and_tags, uint32_t xor_tags);
++static void dwl_ipc_output_set_layout(struct wl_client *client, struct wl_resource *resource, uint32_t index);
++static void dwl_ipc_output_set_tags(struct wl_client *client, struct wl_resource *resource, uint32_t tagmask, uint32_t toggle_tagset);
++static void dwl_ipc_output_release(struct wl_client *client, struct wl_resource *resource);
+ static void focusclient(Client *c, int lift);
+ static void focusmon(const Arg *arg);
+ static void focusstack(const Arg *arg);
+@@ -338,6 +357,7 @@ static void startdrag(struct wl_listener *listener, void *data);
+ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+ static void tile(Monitor *m);
++static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
+ static void togglefullscreen(const Arg *arg);
+ static void toggletag(const Arg *arg);
+@@ -411,6 +431,9 @@ static struct wlr_box sgeom;
+ static struct wl_list mons;
+ static Monitor *selmon;
+ 
++static struct zdwl_ipc_manager_v2_interface dwl_manager_implementation = {.release = dwl_ipc_manager_release, .get_output = dwl_ipc_manager_get_output};
++static struct zdwl_ipc_output_v2_interface dwl_output_implementation = {.release = dwl_ipc_output_release, .set_tags = dwl_ipc_output_set_tags, .set_layout = dwl_ipc_output_set_layout, .set_client_tags = dwl_ipc_output_set_client_tags};
++
+ #ifdef XWAYLAND
+ static void activatex11(struct wl_listener *listener, void *data);
+ static void associatex11(struct wl_listener *listener, void *data);
+@@ -703,6 +726,10 @@ cleanupmon(struct wl_listener *listener, void *data)
+ 	LayerSurface *l, *tmp;
+ 	size_t i;
+ 
++	DwlIpcOutput *ipc_output, *ipc_output_tmp;
++	wl_list_for_each_safe(ipc_output, ipc_output_tmp, &m->dwl_ipc_outputs, link)
++		wl_resource_destroy(ipc_output->resource);
++
+ 	/* m->layers[i] are intentionally not unlinked */
+ 	for (i = 0; i < LENGTH(m->layers); i++) {
+ 		wl_list_for_each_safe(l, tmp, &m->layers[i], link)
+@@ -983,6 +1010,8 @@ createmon(struct wl_listener *listener, void *data)
+ 	m = wlr_output->data = ecalloc(1, sizeof(*m));
+ 	m->wlr_output = wlr_output;
+ 
++	wl_list_init(&m->dwl_ipc_outputs);
++
+ 	for (i = 0; i < LENGTH(m->layers); i++)
+ 		wl_list_init(&m->layers[i]);
+ 
+@@ -1334,6 +1363,192 @@ dirtomon(enum wlr_direction dir)
+ 	return selmon;
+ }
+ 
++void
++dwl_ipc_manager_bind(struct wl_client *client, void *data, uint32_t version, uint32_t id)
++{
++	struct wl_resource *manager_resource = wl_resource_create(client, &zdwl_ipc_manager_v2_interface, version, id);
++	if (!manager_resource) {
++		wl_client_post_no_memory(client);
++		return;
++	}
++	wl_resource_set_implementation(manager_resource, &dwl_manager_implementation, NULL, dwl_ipc_manager_destroy);
++
++	zdwl_ipc_manager_v2_send_tags(manager_resource, TAGCOUNT);
++
++	for (unsigned int i = 0; i < LENGTH(layouts); i++)
++		zdwl_ipc_manager_v2_send_layout(manager_resource, layouts[i].symbol);
++}
++
++void
++dwl_ipc_manager_destroy(struct wl_resource *resource)
++{
++	/* No state to destroy */
++}
++
++void
++dwl_ipc_manager_get_output(struct wl_client *client, struct wl_resource *resource, uint32_t id, struct wl_resource *output)
++{
++	DwlIpcOutput *ipc_output;
++	Monitor *monitor = wlr_output_from_resource(output)->data;
++	struct wl_resource *output_resource = wl_resource_create(client, &zdwl_ipc_output_v2_interface, wl_resource_get_version(resource), id);
++	if (!output_resource)
++		return;
++
++	ipc_output = ecalloc(1, sizeof(*ipc_output));
++	ipc_output->resource = output_resource;
++	ipc_output->mon = monitor;
++	wl_resource_set_implementation(output_resource, &dwl_output_implementation, ipc_output, dwl_ipc_output_destroy);
++	wl_list_insert(&monitor->dwl_ipc_outputs, &ipc_output->link);
++	dwl_ipc_output_printstatus_to(ipc_output);
++}
++
++void
++dwl_ipc_manager_release(struct wl_client *client, struct wl_resource *resource)
++{
++	wl_resource_destroy(resource);
++}
++
++static void
++dwl_ipc_output_destroy(struct wl_resource *resource)
++{
++	DwlIpcOutput *ipc_output = wl_resource_get_user_data(resource);
++	wl_list_remove(&ipc_output->link);
++	free(ipc_output);
++}
++
++void
++dwl_ipc_output_printstatus(Monitor *monitor)
++{
++	DwlIpcOutput *ipc_output;
++	wl_list_for_each(ipc_output, &monitor->dwl_ipc_outputs, link)
++		dwl_ipc_output_printstatus_to(ipc_output);
++}
++
++void
++dwl_ipc_output_printstatus_to(DwlIpcOutput *ipc_output)
++{
++	Monitor *monitor = ipc_output->mon;
++	Client *c, *focused;
++	int tagmask, state, numclients, focused_client, tag;
++	const char *title, *appid;
++	focused = focustop(monitor);
++	zdwl_ipc_output_v2_send_active(ipc_output->resource, monitor == selmon);
++
++	for (tag = 0 ; tag < TAGCOUNT; tag++) {
++		numclients = state = focused_client = 0;
++		tagmask = 1 << tag;
++		if ((tagmask & monitor->tagset[monitor->seltags]) != 0)
++			state |= ZDWL_IPC_OUTPUT_V2_TAG_STATE_ACTIVE;
++
++		wl_list_for_each(c, &clients, link) {
++			if (c->mon != monitor)
++				continue;
++			if (!(c->tags & tagmask))
++				continue;
++			if (c == focused)
++				focused_client = 1;
++			if (c->isurgent)
++				state |= ZDWL_IPC_OUTPUT_V2_TAG_STATE_URGENT;
++
++			numclients++;
++		}
++		zdwl_ipc_output_v2_send_tag(ipc_output->resource, tag, state, numclients, focused_client);
++	}
++	title = focused ? client_get_title(focused) : "";
++	appid = focused ? client_get_appid(focused) : "";
++
++	zdwl_ipc_output_v2_send_layout(ipc_output->resource, monitor->lt[monitor->sellt] - layouts);
++	zdwl_ipc_output_v2_send_title(ipc_output->resource, title);
++	zdwl_ipc_output_v2_send_appid(ipc_output->resource, appid);
++	zdwl_ipc_output_v2_send_layout_symbol(ipc_output->resource, monitor->ltsymbol);
++	if (wl_resource_get_version(ipc_output->resource) >= ZDWL_IPC_OUTPUT_V2_FULLSCREEN_SINCE_VERSION) {
++		zdwl_ipc_output_v2_send_fullscreen(ipc_output->resource, focused ? focused->isfullscreen : 0);
++	}
++	if (wl_resource_get_version(ipc_output->resource) >= ZDWL_IPC_OUTPUT_V2_FLOATING_SINCE_VERSION) {
++		zdwl_ipc_output_v2_send_floating(ipc_output->resource, focused ? focused->isfloating : 0);
++	}
++	zdwl_ipc_output_v2_send_frame(ipc_output->resource);
++}
++
++void
++dwl_ipc_output_set_client_tags(struct wl_client *client, struct wl_resource *resource, uint32_t and_tags, uint32_t xor_tags)
++{
++	DwlIpcOutput *ipc_output;
++	Monitor *monitor;
++	Client *selected_client;
++	unsigned int newtags = 0;
++
++	ipc_output = wl_resource_get_user_data(resource);
++	if (!ipc_output)
++		return;
++
++	monitor = ipc_output->mon;
++	selected_client = focustop(monitor);
++	if (!selected_client)
++		return;
++
++	newtags = (selected_client->tags & and_tags) ^ xor_tags;
++	if (!newtags)
++		return;
++
++	selected_client->tags = newtags;
++	if (selmon == monitor)
++		focusclient(focustop(monitor), 1);
++	arrange(selmon);
++	printstatus();
++}
++
++void
++dwl_ipc_output_set_layout(struct wl_client *client, struct wl_resource *resource, uint32_t index)
++{
++	DwlIpcOutput *ipc_output;
++	Monitor *monitor;
++
++	ipc_output = wl_resource_get_user_data(resource);
++	if (!ipc_output)
++		return;
++
++	monitor = ipc_output->mon;
++	if (index >= LENGTH(layouts))
++		return;
++	if (index != monitor->lt[monitor->sellt] - layouts)
++		monitor->sellt ^= 1;
++
++	monitor->lt[monitor->sellt] = &layouts[index];
++	arrange(monitor);
++	printstatus();
++}
++
++void
++dwl_ipc_output_set_tags(struct wl_client *client, struct wl_resource *resource, uint32_t tagmask, uint32_t toggle_tagset)
++{
++	DwlIpcOutput *ipc_output;
++	Monitor *monitor;
++	unsigned int newtags = tagmask & TAGMASK;
++
++	ipc_output = wl_resource_get_user_data(resource);
++	if (!ipc_output)
++		return;
++	monitor = ipc_output->mon;
++
++	if (!newtags || newtags == monitor->tagset[monitor->seltags])
++		return;
++	if (toggle_tagset)
++		monitor->seltags ^= 1;
++
++	monitor->tagset[monitor->seltags] = newtags;
++	if (selmon == monitor)
++		focusclient(focustop(monitor), 1);
++	arrange(monitor);
++	printstatus();
++}
++
++void
++dwl_ipc_output_release(struct wl_client *client, struct wl_resource *resource)
++{
++	wl_resource_destroy(resource);
++}
++
+ void
+ focusclient(Client *c, int lift)
+ {
+@@ -2033,38 +2248,9 @@ void
+ printstatus(void)
+ {
+ 	Monitor *m = NULL;
+-	Client *c;
+-	uint32_t occ, urg, sel;
+ 
+-	wl_list_for_each(m, &mons, link) {
+-		occ = urg = 0;
+-		wl_list_for_each(c, &clients, link) {
+-			if (c->mon != m)
+-				continue;
+-			occ |= c->tags;
+-			if (c->isurgent)
+-				urg |= c->tags;
+-		}
+-		if ((c = focustop(m))) {
+-			printf("%s title %s\n", m->wlr_output->name, client_get_title(c));
+-			printf("%s appid %s\n", m->wlr_output->name, client_get_appid(c));
+-			printf("%s fullscreen %d\n", m->wlr_output->name, c->isfullscreen);
+-			printf("%s floating %d\n", m->wlr_output->name, c->isfloating);
+-			sel = c->tags;
+-		} else {
+-			printf("%s title \n", m->wlr_output->name);
+-			printf("%s appid \n", m->wlr_output->name);
+-			printf("%s fullscreen \n", m->wlr_output->name);
+-			printf("%s floating \n", m->wlr_output->name);
+-			sel = 0;
+-		}
+-
+-		printf("%s selmon %u\n", m->wlr_output->name, m == selmon);
+-		printf("%s tags %"PRIu32" %"PRIu32" %"PRIu32" %"PRIu32"\n",
+-			m->wlr_output->name, occ, m->tagset[m->seltags], sel, urg);
+-		printf("%s layout %s\n", m->wlr_output->name, m->ltsymbol);
+-	}
+-	fflush(stdout);
++	wl_list_for_each(m, &mons, link)
++		dwl_ipc_output_printstatus(m);
+ }
+ 
+ void
+@@ -2584,6 +2770,8 @@ setup(void)
+ 	LISTEN_STATIC(&output_mgr->events.apply, outputmgrapply);
+ 	LISTEN_STATIC(&output_mgr->events.test, outputmgrtest);
+ 
++	wl_global_create(dpy, &zdwl_ipc_manager_v2_interface, 2, NULL, dwl_ipc_manager_bind);
++
+ 	/* Make sure XWayland clients don't connect to the parent X server,
+ 	 * e.g when running in the x11 backend or the wayland backend and the
+ 	 * compositor has Xwayland support */
+@@ -2681,6 +2869,13 @@ tile(Monitor *m)
+ 	}
+ }
+ 
++void
++togglebar(const Arg *arg) {
++	DwlIpcOutput *ipc_output;
++	wl_list_for_each(ipc_output, &selmon->dwl_ipc_outputs, link)
++		zdwl_ipc_output_v2_send_toggle_visibility(ipc_output->resource);
++}
++
+ void
+ togglefloating(const Arg *arg)
+ {
+diff --git a/protocols/dwl-ipc-unstable-v2.xml b/protocols/dwl-ipc-unstable-v2.xml
+new file mode 100644
+index 0000000..0a6e7e5
+--- /dev/null
++++ b/protocols/dwl-ipc-unstable-v2.xml
+@@ -0,0 +1,181 @@
++<?xml version="1.0" encoding="utf-8"?>
++<!--
++This is largely ripped from somebar's ipc patchset; just with some personal modifications.
++I would probably just submit raphi's patchset but I don't think that would be polite.
++-->
++<protocol name="dwl_ipc_unstable_v2">
++  <description summary="inter-proccess-communication about dwl's state">
++      This protocol allows clients to update and get updates from dwl.
++
++      Warning! The protocol described in this file is experimental and
++      backward incompatible changes may be made. Backward compatible
++      changes may be added together with the corresponding interface
++      version bump.
++      Backward incompatible changes are done by bumping the version
++      number in the protocol and interface names and resetting the
++      interface version. Once the protocol is to be declared stable,
++      the 'z' prefix and the version number in the protocol and
++      interface names are removed and the interface version number is
++      reset.
++  </description>
++
++  <interface name="zdwl_ipc_manager_v2" version="2">
++    <description summary="manage dwl state">
++      This interface is exposed as a global in wl_registry.
++
++      Clients can use this interface to get a dwl_ipc_output.
++      After binding the client will recieve the dwl_ipc_manager.tags and dwl_ipc_manager.layout events.
++      The dwl_ipc_manager.tags and dwl_ipc_manager.layout events expose tags and layouts to the client.
++    </description>
++
++    <request name="release" type="destructor">
++      <description summary="release dwl_ipc_manager">
++        Indicates that the client will not the dwl_ipc_manager object anymore.
++        Objects created through this instance are not affected.
++      </description>
++    </request>
++
++    <request name="get_output">
++      <description summary="get a dwl_ipc_outout for a wl_output">
++        Get a dwl_ipc_outout for the specified wl_output.
++      </description>
++      <arg name="id" type="new_id" interface="zdwl_ipc_output_v2"/>
++      <arg name="output" type="object" interface="wl_output"/>
++    </request>
++
++    <event name="tags">
++      <description summary="Announces tag amount">
++        This event is sent after binding.
++        A roundtrip after binding guarantees the client recieved all tags.
++      </description>
++      <arg name="amount" type="uint"/>
++    </event>
++
++    <event name="layout">
++      <description summary="Announces a layout">
++        This event is sent after binding.
++        A roundtrip after binding guarantees the client recieved all layouts.
++      </description>
++      <arg name="name" type="string"/>
++    </event>
++  </interface>
++
++  <interface name="zdwl_ipc_output_v2" version="2">
++    <description summary="control dwl output">
++      Observe and control a dwl output.
++
++      Events are double-buffered:
++      Clients should cache events and redraw when a dwl_ipc_output.frame event is sent.
++
++      Request are not double-buffered:
++      The compositor will update immediately upon request.
++    </description>
++
++    <enum name="tag_state">
++      <entry name="none" value="0" summary="no state"/>
++      <entry name="active" value="1" summary="tag is active"/>
++      <entry name="urgent" value="2" summary="tag has at least one urgent client"/>
++    </enum>
++
++    <request name="release" type="destructor">
++      <description summary="release dwl_ipc_outout">
++        Indicates to that the client no longer needs this dwl_ipc_output.
++      </description>
++    </request>
++
++    <event name="toggle_visibility">
++      <description summary="Toggle client visibilty">
++        Indicates the client should hide or show themselves.
++        If the client is visible then hide, if hidden then show.
++      </description>
++    </event>
++
++    <event name="active">
++      <description summary="Update the selected output.">
++        Indicates if the output is active. Zero is invalid, nonzero is valid.
++      </description>
++      <arg name="active" type="uint"/>
++    </event>
++
++    <event name="tag">
++      <description summary="Update the state of a tag.">
++        Indicates that a tag has been updated.
++      </description>
++      <arg name="tag" type="uint" summary="Index of the tag"/>
++      <arg name="state" type="uint" enum="tag_state" summary="The state of the tag."/>
++      <arg name="clients" type="uint" summary="The number of clients in the tag."/>
++      <arg name="focused" type="uint" summary="If there is a focused client. Nonzero being valid, zero being invalid."/>
++    </event>
++
++    <event name="layout">
++      <description summary="Update the layout.">
++        Indicates a new layout is selected.
++      </description>
++      <arg name="layout" type="uint" summary="Index of the layout."/>
++    </event>
++
++    <event name="title">
++      <description summary="Update the title.">
++        Indicates the title has changed.
++      </description>
++      <arg name="title" type="string" summary="The new title name."/>
++    </event>
++
++    <event name="appid" since="1">
++      <description summary="Update the appid.">
++        Indicates the appid has changed.
++      </description>
++      <arg name="appid" type="string" summary="The new appid."/>
++    </event>
++
++    <event name="layout_symbol" since="1">
++      <description summary="Update the current layout symbol">
++          Indicates the layout has changed. Since layout symbols are dynamic.
++          As opposed to the zdwl_ipc_manager.layout event, this should take precendence when displaying.
++          You can ignore the zdwl_ipc_output.layout event.
++      </description>
++      <arg name="layout" type="string" summary="The new layout"/>
++    </event>
++
++    <event name="frame">
++      <description summary="The update sequence is done.">
++        Indicates that a sequence of status updates have finished and the client should redraw.
++      </description>
++    </event>
++
++    <request name="set_tags">
++      <description summary="Set the active tags of this output"/>
++      <arg name="tagmask" type="uint" summary="bitmask of the tags that should be set."/>
++      <arg name="toggle_tagset" type="uint" summary="toggle the selected tagset, zero for invalid, nonzero for valid."/>
++    </request>
++
++    <request name="set_client_tags">
++      <description summary="Set the tags of the focused client.">
++        The tags are updated as follows:
++        new_tags = (current_tags AND and_tags) XOR xor_tags
++      </description>
++      <arg name="and_tags" type="uint"/>
++      <arg name="xor_tags" type="uint"/>
++    </request>
++
++    <request name="set_layout">
++      <description summary="Set the layout of this output"/>
++      <arg name="index" type="uint" summary="index of a layout recieved by dwl_ipc_manager.layout"/>
++    </request>
++
++    <!-- Version 2 -->
++    <event name="fullscreen" since="2">
++      <description summary="Update fullscreen status">
++          Indicates if the selected client on this output is fullscreen.
++      </description>
++      <arg name="is_fullscreen" type="uint" summary="If the selected client is fullscreen. Nonzero is valid, zero invalid"/>
++    </event>
++
++    <event name="floating" since="2">
++      <description summary="Update the floating status">
++          Indicates if the selected client on this output is floating.
++      </description>
++      <arg name="is_floating" type="uint" summary="If the selected client is floating. Nonzero is valid, zero invalid"/>
++    </event>
++  </interface>
++</protocol>
+-- 
+2.43.0
+
diff --git a/protocols/dwl-ipc-unstable-v2.xml b/protocols/dwl-ipc-unstable-v2.xml
new file mode 100644
index 0000000..0a6e7e5
--- /dev/null
+++ b/protocols/dwl-ipc-unstable-v2.xml
@@ -0,0 +1,181 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+This is largely ripped from somebar's ipc patchset; just with some personal modifications.
+I would probably just submit raphi's patchset but I don't think that would be polite.
+-->
+<protocol name="dwl_ipc_unstable_v2">
+  <description summary="inter-proccess-communication about dwl's state">
+      This protocol allows clients to update and get updates from dwl.
+
+      Warning! The protocol described in this file is experimental and
+      backward incompatible changes may be made. Backward compatible
+      changes may be added together with the corresponding interface
+      version bump.
+      Backward incompatible changes are done by bumping the version
+      number in the protocol and interface names and resetting the
+      interface version. Once the protocol is to be declared stable,
+      the 'z' prefix and the version number in the protocol and
+      interface names are removed and the interface version number is
+      reset.
+  </description>
+
+  <interface name="zdwl_ipc_manager_v2" version="2">
+    <description summary="manage dwl state">
+      This interface is exposed as a global in wl_registry.
+
+      Clients can use this interface to get a dwl_ipc_output.
+      After binding the client will recieve the dwl_ipc_manager.tags and dwl_ipc_manager.layout events.
+      The dwl_ipc_manager.tags and dwl_ipc_manager.layout events expose tags and layouts to the client.
+    </description>
+
+    <request name="release" type="destructor">
+      <description summary="release dwl_ipc_manager">
+        Indicates that the client will not the dwl_ipc_manager object anymore.
+        Objects created through this instance are not affected.
+      </description>
+    </request>
+
+    <request name="get_output">
+      <description summary="get a dwl_ipc_outout for a wl_output">
+        Get a dwl_ipc_outout for the specified wl_output.
+      </description>
+      <arg name="id" type="new_id" interface="zdwl_ipc_output_v2"/>
+      <arg name="output" type="object" interface="wl_output"/>
+    </request>
+
+    <event name="tags">
+      <description summary="Announces tag amount">
+        This event is sent after binding.
+        A roundtrip after binding guarantees the client recieved all tags.
+      </description>
+      <arg name="amount" type="uint"/>
+    </event>
+
+    <event name="layout">
+      <description summary="Announces a layout">
+        This event is sent after binding.
+        A roundtrip after binding guarantees the client recieved all layouts.
+      </description>
+      <arg name="name" type="string"/>
+    </event>
+  </interface>
+
+  <interface name="zdwl_ipc_output_v2" version="2">
+    <description summary="control dwl output">
+      Observe and control a dwl output.
+
+      Events are double-buffered:
+      Clients should cache events and redraw when a dwl_ipc_output.frame event is sent.
+
+      Request are not double-buffered:
+      The compositor will update immediately upon request.
+    </description>
+
+    <enum name="tag_state">
+      <entry name="none" value="0" summary="no state"/>
+      <entry name="active" value="1" summary="tag is active"/>
+      <entry name="urgent" value="2" summary="tag has at least one urgent client"/>
+    </enum>
+
+    <request name="release" type="destructor">
+      <description summary="release dwl_ipc_outout">
+        Indicates to that the client no longer needs this dwl_ipc_output.
+      </description>
+    </request>
+
+    <event name="toggle_visibility">
+      <description summary="Toggle client visibilty">
+        Indicates the client should hide or show themselves.
+        If the client is visible then hide, if hidden then show.
+      </description>
+    </event>
+
+    <event name="active">
+      <description summary="Update the selected output.">
+        Indicates if the output is active. Zero is invalid, nonzero is valid.
+      </description>
+      <arg name="active" type="uint"/>
+    </event>
+
+    <event name="tag">
+      <description summary="Update the state of a tag.">
+        Indicates that a tag has been updated.
+      </description>
+      <arg name="tag" type="uint" summary="Index of the tag"/>
+      <arg name="state" type="uint" enum="tag_state" summary="The state of the tag."/>
+      <arg name="clients" type="uint" summary="The number of clients in the tag."/>
+      <arg name="focused" type="uint" summary="If there is a focused client. Nonzero being valid, zero being invalid."/>
+    </event>
+
+    <event name="layout">
+      <description summary="Update the layout.">
+        Indicates a new layout is selected.
+      </description>
+      <arg name="layout" type="uint" summary="Index of the layout."/>
+    </event>
+
+    <event name="title">
+      <description summary="Update the title.">
+        Indicates the title has changed.
+      </description>
+      <arg name="title" type="string" summary="The new title name."/>
+    </event>
+
+    <event name="appid" since="1">
+      <description summary="Update the appid.">
+        Indicates the appid has changed.
+      </description>
+      <arg name="appid" type="string" summary="The new appid."/>
+    </event>
+
+    <event name="layout_symbol" since="1">
+      <description summary="Update the current layout symbol">
+          Indicates the layout has changed. Since layout symbols are dynamic.
+          As opposed to the zdwl_ipc_manager.layout event, this should take precendence when displaying.
+          You can ignore the zdwl_ipc_output.layout event.
+      </description>
+      <arg name="layout" type="string" summary="The new layout"/>
+    </event>
+
+    <event name="frame">
+      <description summary="The update sequence is done.">
+        Indicates that a sequence of status updates have finished and the client should redraw.
+      </description>
+    </event>
+
+    <request name="set_tags">
+      <description summary="Set the active tags of this output"/>
+      <arg name="tagmask" type="uint" summary="bitmask of the tags that should be set."/>
+      <arg name="toggle_tagset" type="uint" summary="toggle the selected tagset, zero for invalid, nonzero for valid."/>
+    </request>
+
+    <request name="set_client_tags">
+      <description summary="Set the tags of the focused client.">
+        The tags are updated as follows:
+        new_tags = (current_tags AND and_tags) XOR xor_tags
+      </description>
+      <arg name="and_tags" type="uint"/>
+      <arg name="xor_tags" type="uint"/>
+    </request>
+
+    <request name="set_layout">
+      <description summary="Set the layout of this output"/>
+      <arg name="index" type="uint" summary="index of a layout recieved by dwl_ipc_manager.layout"/>
+    </request>
+
+    <!-- Version 2 -->
+    <event name="fullscreen" since="2">
+      <description summary="Update fullscreen status">
+          Indicates if the selected client on this output is fullscreen.
+      </description>
+      <arg name="is_fullscreen" type="uint" summary="If the selected client is fullscreen. Nonzero is valid, zero invalid"/>
+    </event>
+
+    <event name="floating" since="2">
+      <description summary="Update the floating status">
+          Indicates if the selected client on this output is floating.
+      </description>
+      <arg name="is_floating" type="uint" summary="If the selected client is floating. Nonzero is valid, zero invalid"/>
+    </event>
+  </interface>
+</protocol>
diff --git a/startup.sh b/startup.sh
new file mode 120000
index 0000000..51bbeeb
--- /dev/null
+++ b/startup.sh
@@ -0,0 +1 @@
+/home/carlos/repos/dotfiles/dwl/startup.sh
\ No newline at end of file
